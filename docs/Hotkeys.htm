<!DOCTYPE HTML>
<meta charset="utf-8">
<html>
<head>
<title>핫키[Hotkeys] (마우스, 조이스틱 및 키보드 단축키)</title>
<meta name="description" content="Free utility to create hotkeys, shortcuts, and macros for keyboard, mouse, and joystick. Any combination of keys and buttons can become a hotkey.">
<meta name="keywords" content="hotkey,hotkeys,hot key,hot keys,shortcut,shortcuts,shortcut key,shortcut keys,keyboard shortcut,keyboard shortcuts,button,buttons,click,press">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>핫키[Hotkeys] (마우스, 조이스틱 및 키보드 단축키)</h1>


<h2>목차</h2>
<ul>
  <li><a href="#Intro">소개 및 간단한 예제들</a></li>
  <li><a href="#Symbols">핫키 접두 기호 테이블 (제어자)</a></li>
  <li><a href="#Context">특정 상황에 사용되는 핫키</a></li>
  <li><a href="#combo">커스텀 조합</a></li>
  <li><a href="#Features">다른 기능들</a></li>
  <li><a href="#Wheel">마우스 휠 핫키</a></li>
  <li><a href="#Remarks">핫키 팁 및 비고</a></li>
  <li><a href="#AltTabDetail">알트탭 핫키</a></li>
  <li><a href="#Function">함수 핫키</a></li>
</ul>

<h2 id="Intro">소개 및 간단한 예제들</h2>
<p>핫키는 때때로 프로그램이나 <a href="misc/Macros.htm">키보드 매크로</a>를 실행하는 등의 특정 액션을 쉽게 실행시켜준 다는 점에서 단축키로 여겨진다.
  아래의 예제속에서, 핫키 Win+N은 메모장을 열도록 설정되어있다. # 기호는 <em>제어자</em>로써 윈도우 키를 나타낸다.
<pre>#n::
Run Notepad
return</pre>
<p>위 마지막줄에,  <code><a href="commands/Return.htm">return</a></code>은 이 핫키를 끝내는 기능을 제공한다.
  하지만, 만약 핫키가 오직 한줄만 실행해도 된다면, 그 라인은 더블 콜론(::)의 오른편에 작성할 수도 있다.
  다시 말하면, <code><a href="commands/Return.htm">return</a></code>은 함축된다:</p>
<pre>#n::Run Notepad</pre>
<p>하나 이상의 제어자를 핫키에 사용하고 싶을 경우에, 나란히 나열하면된다.(순서는 중요하지 않다)
  다음의 예제는 Control+Alt+S를 나타내기 위하여 <code>^!s</code>를 사용하였다:</p>
<pre>^!s::
<a href="commands/Send.htm">Send</a> 진심을 담아,{enter}John Smith  <em>; 이 라인은 (가장 위에) 활성화 된 창(윈도우의 창을 의미)에 키 입력을 전송한다.</em>
return</pre>
<h3 id="Symbols">여러분은 여러분의 핫키를 정의하기 위하여 다음의 제어자 심볼을 사용할 수 있다:</h3>
<table class="info">
  <tr>
    <th style="width:30px">심볼</th>
    <th>설명</th>
  </tr>
  <tr>
    <td><strong>#</strong></td>
    <td>Win (윈도우 로고키). In v1.0.48.01+, 윈도우 비스타 이후 제품을 위해서, 윈도우 키를 포함하는 핫키(예: #a)는 &quot;L&quot; 키입력이 포함된 문자열을 보내기 전에
      윈도우 키가 릴리즈 되는 것을 기다릴 것이다. 이를 통해서 <a href="commands/Send.htm">Send</a>를 사용할 때 컴퓨터가 잠기는 것을 예방할 수 있다.
      이 행동은 <a href="commands/Send.htm#SendPlayDetail">SendPlay</a> (위 기능이 필요 없는)와 <a href="commands/Send.htm#blind">blind mode</a>
      를 제외한 모든 전송모드(Sending mode)에서 적용된다.</td>
  </tr>
  <tr>
    <td><strong>!</strong></td>
    <td>Alt</td>
  </tr>
  <tr>
    <td><strong>^</strong></td>
    <td>Control</td>
  </tr>
  <tr>
    <td><strong>+</strong></td>
    <td>Shift</td>
  </tr>
  <tr>
    <td><strong>&amp;</strong></td>
    <td>두 키보드 또는 마우스 버튼으로 새로운 커스텀 핫키를 만들 때 사용한다. 자세한 사항은 <a href="#combo">below</a>를 참고한다.</td>
  </tr>
  <tr id="LeftRight">
    <td><strong>&lt;</strong></td>
    <td>한쌍으로 이루어진 키 중에 왼쪽키를 사용한다. 예: &lt;!a 는 왼쪽 Alt로만 사용한다는 점을 제외하고는 !a
      와 동일하다.</td>
  </tr>
  <tr>
    <td><strong>&gt;</strong></td>
    <td>한쌍으로 이루어진 키 중에 오른쪽키를 사용한다.</td>
  </tr>
  <tr id="AltGr">
    <td><strong>&lt;^&gt;!</strong></td>
    <td><p>AltGr (유럽이나 아메리카 대륙(미국 표준 QWERTY 자판은 제외)의 키보드 수식 키 중에 하나로, 주로 해당 언어에서 잘 안 쓰이는 문자(주로 악센트가 첨가된 문자나 화폐 기호 등)를 입력하기 위한 용도로 쓰인다. 이 키는 대개 '물리적'으로는 오른쪽 Alt 키가 대신하고 있다.) 만약 여러분의 키보드 레이아웃이 오른쪽 Alt가 아닌 AltGr을 가지고 있다면, 이 심볼이 AltGr을 나타낸다. 예시는 다음과 같다:</p>
      <pre>&lt;^&gt;!m::MsgBox 당신은 AltGr+m을 눌렀습니다.
&lt;^&lt;!m::MsgBox 당신은 LeftControl+LeftAlt+m을 눌렀습니다.</pre>
      <p>대안으로, AltGr 그 자체를 핫키로 만들기 위해서, 위와 같은 단축키없이 다음을 사용한다:</p>
      <pre>LControl &amp; RAlt::MsgBox 당신은 AltGr을 눌렀습니다.</pre></td>
  </tr>
  <tr id="wildcard">
    <td><strong>*</strong></td>
    <td><p>와일드카드(포커에서 조커 느낌임): 추가 수식어가 눌릴 경우에도 핫키를 실행시킨다.
      이 키는 주로 <a href="misc/Remap.htm">리매핑</a> 키나 버튼과 함께 주로 사용된다. 예시:</p>
      <pre>*#c::Run Calc.exe  <em>; Win+C, Shift+Win+C, Ctrl+Win+C, 등이 모두 이 핫키를 실행시킨다.</em>
*ScrollLock::Run Notepad  <em>; 제어자 키에서 손을띄더라도 ScrollLock를 누르고 있음으로써, 이 핫키는 실행된다.</em></pre></td>
  </tr>
  <tr id="Tilde">
    <td><strong>~</strong></td>
    <td><p>핫키가 실행될 때, 이 키의 고유의 기능은 중단되지 않는다. 아래의 두개의 예시에서, 사용자의 마우스 버튼 클릭은 액티브 윈도우(실행되고 있는 창)으로 전송될 것이다:</p>
      <pre>~RButton::MsgBox 당신은 마우스 오른쪽 버튼을 클릭했습니다.
~RButton &amp; C::MsgBox 당신은 마우스 오른쪽 버튼을 누른 상태로 C 를 눌렀습니다.</pre>
      <p>다른 접두어 심볼들과 다르게, ~ 접두어는 몇 핫키의 <a href="commands/_IfWinActive.htm#variant">변형(중복)</a>에 표시되기도 한다. 그러나 ~ 표시가 종료되지 않았거나, 일시 중지 되지 않은 조합의 <a href="#prefix">접두어</a>에 사용될 경우, 해당 접두어의 <em>모든</em> 키 조합에 영향을 미친다.</p>
      <p> <a href="#alttab">alt-tab</a>을 대체하는 특별한 핫키들은 언제나 ~ 접두어를 무시한다.</p>
      <p><span class="ver">[v1.1.14+]:</span> 만약 ~ 단축키가 기존에 핫키로 사용되고 있는 커스텀 키에 적용된다면, 그 핫키는 키를 놓을 때까지 기다려지는 것이 아니라 키를 누를 때 실행될 것이다. 예를들어, 위의 <em>~RButton</em> 핫키는 버튼이 눌리자 마자 실행될 것이다. v1.1.14버전 이전에는 (또는 ~ 접두어가 있기 전), 이 것은 버튼이 띄어졌을때 실행되었었지만, 위의 <em>RButton &amp; C</em> 조합이 활성화 되지 않을 경우에만 가능했다.</p>
      <p>만약 ~ 접두어가 오직 커스텀 조합에만 적용된다면, 그키 자체의 고유의 기능은 여전히 중단된다. 예를들어 아래의 예시에서, AppsKey를 누르고 있을 경우 ToolTip은 보이나 context menu를 실행시키지는 않을 것이다:</p>
      <pre>AppsKey::ToolTip Press &lt; or &gt; to cycle through windows.
AppsKey Up::ToolTip
~AppsKey &amp; &lt;::Send !+{Esc}
~AppsKey &amp; &gt;::Send !{Esc}</pre>
    </td>
  </tr>
  <tr id="prefixdollar">
    <td><strong>$</strong></td>
    <td>
      <p>This is usually only necessary if the script uses the <a href="commands/Send.htm">Send</a> command to send the keys that comprise the hotkey itself, which might otherwise cause it to trigger itself. The $ prefix forces the <a href="commands/_InstallKeybdHook.htm">keyboard hook</a> to be used to implement this hotkey, which as a side-effect prevents the <a href="commands/Send.htm">Send</a> command from triggering it. The $ prefix is equivalent to having specified <code><a href="commands/_UseHook.htm">#UseHook</a></code> somewhere above the definition of this hotkey.</p>
      <p>The $ prefix has no effect for mouse hotkeys, since they always use the mouse hook. It also has no effect for hotkeys which already require the keyboard hook, including any keyboard hotkeys with the <a href="#Tilde">tilde (~)</a> or <a href="#wildcard">wildcard (*)</a> modifiers, key-up hotkeys and custom combinations.</p>
      <p><span class="ver">[v1.1.06+]:</span> <a href="commands/_InputLevel.htm">#InputLevel</a> and <a href="commands/SendLevel.htm">SendLevel</a> provide additional control over which hotkeys and hotstrings are triggered by the Send command.</p>
    </td>
  </tr>
  <tr id="keyup">
    <td>UP</td>
    <td><p>The word UP may follow the name of a hotkey to cause the hotkey to fire upon release of the key rather than when the key is pressed down. The following example <a href="misc/Remap.htm">remaps</a> LWin to become LControl:</p>
      <pre>*LWin::Send {LControl Down}
*LWin <strong>Up</strong>::Send {LControl Up}
</pre>
      <p>&quot;Up&quot; can also be used with normal hotkeys as in this example: <code>^!r Up::MsgBox You pressed and released Ctrl+Alt+R</code>. It also works with <a href="#combo">combination hotkeys</a> (e.g. <code>F1 &amp; e Up::</code>)</p>
      <p>Limitations: 1) &quot;Up&quot; does not work with <a href="KeyList.htm">joystick buttons</a>; and 2) An &quot;Up&quot; hotkey without a normal/down counterpart hotkey will completely take over that key to prevent it from getting stuck down. One way to prevent this is to add a <a href="#Tilde">tilde prefix</a> (e.g. <code><strong>~</strong>LControl up::</code>)</p>
      <p>On a related note, a technique similar to the above is to make a hotkey into a prefix key. The advantage is that although the hotkey will fire upon release, it will do so only if you did not press any other key while it was held down. For example:</p>
      <pre>LControl &amp; F1::return  <em>; Make left-control a prefix by using it in front of &quot;&amp;&quot; at least once.</em>
LControl::MsgBox You released LControl without having used it to modify any other key.</pre></td>
  </tr>
</table>
<p><strong>(See the <a href="KeyList.htm">Key List</a> for a complete list of keyboard keys and mouse/joystick buttons)</strong></p>
<p><br>
Multiple hotkeys can be stacked vertically to have them perform the same action. For example:</p>
<pre>^Numpad0::
^Numpad1::
MsgBox Pressing either Control+Numpad0 or Control+Numpad1 will display this message.
return</pre>
<p>A key or key-combination can be disabled for the entire system by having it do nothing. The following example disables the right-side Windows key:</p>
<pre>RWin::return</pre>

<h2 id="Context">Context-sensitive Hotkeys</h2>
<p>The directives <a href="commands/_IfWinActive.htm">#IfWinActive/Exist</a> and <a href="commands/_If.htm">#If</a> can be used to make a hotkey perform a different action (or none at all) depending on a specific condition. For example:</p>
<pre>#IfWinActive, ahk_class Notepad
^a::MsgBox You pressed Ctrl-A while Notepad is active. Pressing Ctrl-A in any other window will pass the Ctrl-A keystroke to that window.
#c::MsgBox You pressed Win-C while Notepad is active.

#IfWinActive
#c::MsgBox You pressed Win-C while any window except Notepad is active.

#If <a href="commands/_If.htm#Examples">MouseIsOver</a>("ahk_class Shell_TrayWnd")
WheelUp::Send {Volume_Up}     <em>; Wheel over taskbar: increase/decrease volume.</em>
WheelDown::Send {Volume_Down} <em>;</em>
</pre>

<h2 id="combo">Custom Combinations</h2>
<p>You can define a custom combination of two keys (except joystick buttons) by using &quot; &amp; &quot; between them. In the below example, you would hold down Numpad0 then press the second key to trigger the hotkey:</p>
<pre id="prefix">Numpad0 <strong>&amp;</strong> Numpad1::MsgBox You pressed Numpad1 while holding down Numpad0.
Numpad0 <strong>&amp;</strong> Numpad2::Run Notepad</pre>
<p><strong>The prefix key loses its native function:</strong> In the above example, Numpad0 becomes a <em>prefix key</em>; but this also causes Numpad0 to lose its original/native function when it is pressed by itself. To avoid this, a script may configure Numpad0 to perform a new action such as one of the following:</p>
<pre>Numpad0::WinMaximize A   <em>; Maximize the active/foreground window.</em>
Numpad0::Send {Numpad0}  <em>; Make the <i>release</i> of Numpad0 produce a Numpad0 keystroke. See comment below.</em></pre>
<p><strong>Fire on release:</strong> The presence of one of the above custom combination hotkeys causes the <em>release</em> of Numpad0 to perform the indicated action, but only if you did not press any other keys while Numpad0 was being held down.  In v1.1.14+, this behaviour can be avoided by applying the <a href="#Tilde">tilde prefix</a> to either hotkey.</p>
<p id="combo_mods"><strong>Modifiers:</strong> Unlike a normal hotkey, custom combinations act as though they have the <a href="#wildcard">wildcard (*)</a> modifier by default. For example, <code>1 &amp; 2::</code> will activate even if Ctrl or Alt is held down when 1 and 2 are pressed, whereas <code>^1::</code> would be activated only by Ctrl+1 and not Ctrl+Alt+1.</p>
<p>For standard modifier keys, normal hotkeys typically work as well or better than "custom" combinations. For example, <code>&lt;+s::</code> is recommended over <code>LShift &amp; s::</code>.</p>
<p>Combinations of three or more keys are not supported. Combinations which your keyboard hardware supports can usually be detected by using <a href="commands/_If.htm">#If</a> and <a href="commands/GetKeyState.htm">GetKeyState</a>, but the results may be inconsistent. For example:</p>
<pre><em>; Press AppsKey and Alt in any order, then slash (/).</em>
#if GetKeyState("AppsKey", "P")
Alt &amp; /::MsgBox Hotkey activated.

<em>; If the keys are swapped, Alt must be pressed first (use one at a time):</em>
#if GetKeyState("Alt", "P")
AppsKey &amp; /::MsgBox Hotkey activated.

<em>; [ &amp; ] &amp; \::</em>
#if GetKeyState("[") &amp;&amp; GetKeyState("]")
\::MsgBox</pre>

<h2 id="Features">Other Features</h2>
<p><strong>Numlock, Capslock, and Scrolllock:</strong> These keys may be forced to be &quot;AlwaysOn&quot; or &quot;AlwaysOff&quot;. For example: <code><a href="commands/SetNumScrollCapsLockState.htm">SetNumlockState</a> AlwaysOn</code>.</p>
<p><strong>Overriding Explorer's hotkeys:</strong> Windows' built-in hotkeys such as Win-E (#e) and Win-R (#r) can be individually overridden simply by assigning them to an action in the script. See the <a href="misc/Override.htm">override page</a> for details.</p>
<p id="alttab"><strong>Substitutes for Alt-Tab:</strong> Hotkeys can provide an alternate means of alt-tabbing. For example, the following two hotkeys allow you to alt-tab with your right hand:</p>
<pre>RControl &amp; RShift::AltTab  <em>; Hold down right-control then press right-shift repeatedly to move forward.</em>
RControl &amp; Enter::ShiftAltTab  <em>; Without even having to release right-control, press Enter to reverse direction.</em></pre>
<p>For more details, see <a href="#AltTabDetail">Alt-Tab</a>.</p>

<h2 id="Wheel">Mouse Wheel Hotkeys</h2>
<p>Hotkeys that fire upon turning the mouse wheel are supported via the key names WheelDown and WheelUp. WheelLeft and WheelRight are also supported in v1.0.48+, but have no effect on operating systems older than Windows Vista. Here are some examples of mouse wheel hotkeys:</p>
<pre>MButton &amp; WheelDown::MsgBox You turned the mouse wheel down while holding down the middle button.
^!WheelUp::MsgBox You rotated the wheel up while holding down Control+Alt.</pre>
<p>In v1.0.43.03+, the built-in variable <strong>A_EventInfo</strong> contains the amount by which the wheel was turned, which is typically 1. However, A_EventInfo can be greater or less than 1 under the following circumstances:</p>
<ul>
  <li>If the mouse hardware reports distances of less than one notch, A_EventInfo may contain 0;</li>
  <li>If the wheel is being turned quickly (depending on type of mouse), A_EventInfo may be greater than 1. A hotkey like the following can help analyze your mouse: <code>~WheelDown::ToolTip %A_EventInfo%</code>.</li>
</ul>
<p>Some of the most useful hotkeys for the mouse wheel involve alternate modes of scrolling a window's text. For example, the following pair of hotkeys scrolls horizontally instead of vertically when you turn the wheel while holding down the left Control key:</p>
<pre>~LControl &amp; WheelUp::  <em>; Scroll left.</em>
ControlGetFocus, fcontrol, A
Loop 2  <em>; &lt;-- Increase this value to scroll faster.</em>
    SendMessage, 0x114, 0, 0, %fcontrol%, A  <em>; 0x114 is WM_HSCROLL and the 0 after it is SB_LINELEFT.</em>
return

~LControl &amp; WheelDown::  <em>; Scroll right.</em>
ControlGetFocus, fcontrol, A
Loop 2  <em>; &lt;-- Increase this value to scroll faster.</em>
    SendMessage, 0x114, 1, 0, %fcontrol%, A  <em>; 0x114 is WM_HSCROLL and the 1 after it is SB_LINERIGHT.</em>
return</pre>
<p>Finally, since mouse wheel hotkeys generate only down-events (never up-events), they cannot be used as <a href="#keyup">key-up hotkeys</a>.</p>

<h2 id="Remarks">Hotkey Tips and Remarks</h2>
<p>Each numpad key can be made to launch two different hotkey subroutines depending on the state of Numlock. Alternatively, a numpad key can be made to launch the same subroutine regardless of the Numlock state. For example:</p>
<pre>NumpadEnd::
Numpad1::
MsgBox, This hotkey is launched regardless of whether Numlock is on.
return</pre>
<p>If the <a href="#Tilde">tilde (~) operator</a> is used with a <a href="#prefix">prefix key</a> even once, it changes the behavior of that prefix key for all combinations. For example, in both of the below hotkeys, the active window will receive all right-clicks even though only one of the definitions contains a tilde:</p>
<pre>~RButton &amp; LButton::MsgBox You pressed the left mouse button while holding down the right.
RButton &amp; WheelUp::MsgBox You turned the mouse wheel up while holding down the right button.</pre>
<p>The <a href="commands/Suspend.htm">Suspend</a> command can temporarily disable all hotkeys except for ones you make exempt. For greater selectivity, use <a href="commands/_IfWinActive.htm">#IfWinActive/Exist</a>.</p>
<p>By means of the <a href="commands/Hotkey.htm">Hotkey</a> command, hotkeys can be created dynamically while the script is running. The Hotkey command can also modify, disable, or enable the script's existing hotkeys individually.</p>
<p>Joystick hotkeys do not currently support modifier prefixes such as ^ (Control) and # (Win). However, you can use <a href="commands/GetKeyState.htm">GetKeyState</a> to mimic this effect as shown in the following example:</p>
<pre>Joy2::
if not GetKeyState(&quot;Control&quot;)  <em>; Neither the left nor right Control key is down.</em>
    return  <em>; i.e. Do nothing.</em>
MsgBox You pressed the first joystick's second button while holding down the Control key.
return</pre>
<p>There may be times when a hotkey should wait for its own modifier keys to be released before continuing. Consider the following example:</p>
<pre>^!s::Send {Delete}</pre>
<p>Pressing Control-Alt-S would cause the system to behave as though you pressed Control-Alt-Delete (due to the system's aggressive detection of Ctrl-Alt-Delete). To work around this, use <a href="commands/KeyWait.htm">KeyWait</a> to wait for the keys to be released; for example:</p>
<pre>^!s::
KeyWait Control
KeyWait Alt
Send {Delete}
return</pre>
<p>If a hotkey label like <code>#z::</code> produces an error like &quot;Invalid Hotkey&quot;, your system's keyboard layout/language might not have the specified character (&quot;Z&quot; in this case). Try using a different character that you know exists in your keyboard layout.</p>
<p>A hotkey label can be used as the target of a <a href="commands/Gosub.htm">Gosub</a> or <a href="commands/Goto.htm">Goto</a>. For example: <code>Gosub ^!s</code>.</p>
<p>One common use for hotkeys is to start and stop a repeating action, such as a series of keystrokes or mouse clicks. For an example of this, see <a href="FAQ.htm#repeat">this FAQ topic</a>.</p>
<p>Finally, each script is <a href="misc/Threads.htm">quasi multi-threaded</a>, which allows a new hotkey to be launched even when a previous hotkey subroutine is still running. For example, new hotkeys can be launched even while a <a href="commands/MsgBox.htm">MsgBox</a> is being displayed by the current hotkey.</p>

<h2 id="AltTabDetail">Alt-Tab Hotkeys</h2>
<p>Each Alt-Tab hotkey must be a combination of two keys, which is typically achieved via the ampersand symbol (&amp;). In the following example, you would hold down the right Alt key and press J or K to navigate the alt-tab menu:</p>
<pre>RAlt &amp; j::AltTab
RAlt &amp; k::ShiftAltTab</pre>
<p><em>AltTab</em> and <em>ShiftAltTab</em> are two of the special commands that are only recognized when used on the same line as a hotkey. Here is the complete list:</p>
<p><strong>AltTab</strong>: If the alt-tab menu is visible, move forward in it. Otherwise, display the menu (only if the hotkey is an &quot;&amp;&quot; combination of two keys; otherwise, it does nothing).</p>
<p><strong>ShiftAltTab</strong>: Same as above except move backward in the menu.</p>
<p><strong>AltTabAndMenu</strong>: If the alt-tab menu is visible, move forward in it. Otherwise, display the menu.</p>
<p><strong>AltTabMenuDismiss</strong>: Close the Alt-tab menu.</p>
<p>To illustrate the above, the mouse wheel can be made into an entire substitute for Alt-tab. With the following hotkeys in effect, clicking the middle button displays the menu and turning the wheel navigates through it:</p>
<pre>MButton::AltTabMenu
WheelDown::AltTab
WheelUp::ShiftAltTab</pre>
<p>To cancel a hotkey-invoked Alt-tab menu without activating the selected window, use a hotkey such as the following. It might require adjustment depending on: 1) the means by which the alt-tab menu was originally displayed; and 2) whether the script has the <a href="commands/_InstallKeybdHook.htm">keyboard hook</a> installed.</p>
<pre>LCtrl &amp; CapsLock::AltTab
<strong>!</strong>MButton::  <em>; Middle mouse button. The <strong>!</strong> prefix makes it fire while the Alt key is down (which it is if the alt-tab menu is visible).</em>
IfWinExist ahk_class #32771  <em>; Indicates that the alt-tab menu is present on the screen.</em>
    Send <strong>!</strong>{Escape}{Alt up}
return</pre>
<p>Currently, all special Alt-tab actions must be assigned directly to a hotkey as in the examples above (i.e. they cannot be used as though they were commands). They are <span class="red">not affected by <a href="commands/_IfWinActive.htm">#IfWin</a> or <a href="commands/_If.htm">#If</a></span>.</p>
<p>Custom alt-tab actions can also be created via hotkeys. In the following example, you would press F1 to display the menu and advance forward in it. Then you would press F2 to activate the selected window (or press Escape to cancel):</p>
<pre>*F1::Send {Alt down}{tab} <em>; Asterisk is required in this case.</em>
!F2::Send {Alt up}  <em>; Release the Alt key, which activates the selected window.</em>
~*Escape::
IfWinExist ahk_class #32771
    Send {Escape}{Alt up}  <em>; Cancel the menu without activating the selected window.</em>
return</pre>

<h2 id="Function">Function Hotkeys <span class="ver">[v1.1.20+]</span></h2>
<p>One or more hotkeys can be assigned a <a href="Functions.htm">function</a> by simply defining it immediately after the hotkey label as in this example:</p>
<pre><em>; Ctrl+Shift+O to open containing folder in Explorer.
; Ctrl+Shift+E to open folder with current file selected.
; Supports SciTE and Notepad++.</em>
^+o::
^+e::
    editor_open_folder() {
        WinGetTitle, path, A
        if RegExMatch(path, "\*?\K(.*)\\[^\\]+(?= [-*] )", path)
            if (FileExist(path) &amp;&amp; A_ThisHotkey = "^+e")
                Run explorer.exe /select`,"%path%"
            else
                Run explorer.exe "%path1%"
    }</pre>
<p>There must only be whitespace, comments or directives between the hotkey labels or label and the function. No label is created for hotkeys defined this way; however, the <a href="Scripts.htm#auto">auto-execute section</a> ends at the first hotkey even if it is assigned a function.</p>
<p>The main benefit of using a function is that local variables can be used, which avoids conflicts when two or more hotkeys use the same variable names for different purposes. It also encourages self-documenting hotkeys, like in the code above where the function name describes the hotkey.</p>
<p>The <a href="commands/Hotkey.htm">Hotkey</a> command can also be used to assign a function or function object to a hotkey.</p>

</body>
</html>
